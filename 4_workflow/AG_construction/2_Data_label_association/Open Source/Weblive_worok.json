[
    {
        "title": "clrload: clr assembly loader",
        "content": "CLRLoad is a generic Windows PE that we have seen in both 32-and 64-bit versions. It is a loader written in C++ that loads the next stage (PNGLoad), which must be aCommon Language Runtime (CLR) assemblyDLL file. That code is loaded from a file located on disk in a legitimate directory, presumably to mislead victims or incident responders into thinking it is legitimate software.\nSome CLRLoad samples start by decoding the full path of the file whose content they will load as the next stage. These file paths are encoded with a single-byte XOR, with a different key in every sample. Decoded or cleartext, these file paths are absolute, with the following being those we have encountered:\nC:\\Program Files\\VMware\\VMware Tools\\VMware VGAuth\\xsec_1_5.dll \nC:\\Program Files\\UltraViewer\\msvbvm80.dll \nC:\\Program Files\\Internet Explorer\\Jsprofile.dll \nC:\\Program Files\\WinRar\\RarExtMgt.dll \nC:\\Program Files (x86)\\Foxit Software\\Foxit Reader\\lucenelib.dll\nNext, a mutex is created and we've seen a different name in every sample. The loader checks for this mutex; if found, it exits, because the loader is already running. In one of the samples, the mutexWo0r0KGWhYGOwas encountered, which gave the group its name of Worok.\nCLRLoad then loads a CLR assembly from the possibly decoded file path. As unmanaged code, CLRLoad achieves this viaCorBindToRuntimeExWindows API calls in 32-bit variants, orCLRCreateInstancecalls in 64-bit variants.",
        "phase": "other"
    },
    {
        "title": "powheartbeat: powershell backdoor",
        "content": "PowHeartBeat is a full-featured backdoor written in PowerShell, obfuscated using various techniques such as  compression, encoding, and encryption. Based on ESET telemetry, we believe PowHeartBeat replaced CLRLoad in more recent Worok campaigns as the tool used to launch PNGLoad.\nThe first layer of the backdoor code consists of multiple chunks of base64-encoded PowerShell code. Once the payload is reconstructed, it is executed viaIEX. Once decoded, another layer of obfuscated code is executed, which we can see in Figure 3.\nThe second layer of the backdoor first base64 decodes the next layer of its code, which is then decrypted withTriple DES(CBC mode). After decryption, this code is decompressed using thegzipalgorithm, thus giving the third layer of PowerShell code, which is the actual backdoor. It is divided into two main parts: configuration, and handling backdoor commands.\nThe main layer of backdoor code is also written in PowerShell and uses HTTP or ICMP to communicate with the C&C server. It works as depicted in Figure 4.",
        "phase": "command and control"
    },
    {
        "title": "configuration",
        "content": "The configuration contains multiple fields, including version number, optional proxy configuration, and C&C address. Table 1 describes the meanings of the configuration fields in the different versions we have observed.\nTable 1. Configuration field meanings\nFigure 5 shows an example of the configuration extracted from a PowHeartBeat sample (SHA-1:757ABA12D04FD1167528FDD107A441D11CD8C427).\nFigure 5. Configuration example",
        "phase": "command and control"
    },
    {
        "title": "data encryption",
        "content": "PowHeartBeat encrypts logs and additional configuration file content.\nLog file content is encrypted though multiple-byte XOR with a key specified in cleartext in the sample. Interestingly,clientIdis used as a salt for the index into the key array. The key is a 256-byte array, which was identical in every sample that we encountered. Additional configuration file content is encrypted through multiple-byte XOR with the value fromSecretKeyas its key.",
        "phase": "other"
    },
    {
        "title": "http",
        "content": "In an infinite loop, the backdoor sends a GET request to the C&C server, asking for a command to issue. The encrypted answer is decrypted by the backdoor, which processes the command, and writes the command output to a file whose content is then sent to the C&C server via a POST request.\nThe format of the GET requests is the following:\nNote that the request is constructed using the eponymous configuration fields.\nIn the response from the C&C server, the third byte of the content is the command identifier that indicates the command to be processed by the backdoor. We'll call itcommand_id. The remaining content of the response will be passed as an argument to the command that is processed. This content is encrypted with the algorithm shown in Figure 6,taskIdbeing the value of the cookie named afterCookieTaskId's value from the configuration.\nFigure 6. Requests content data encryption algorithm\nThe response from the C&C server also contains another cookie, whose name is specified by the backdoor'sCookieTerminalIdconfiguration variable. The value of this cookie is repeated in the POST request from the backdoor, and it must not be empty. After executing the backdoor command, PowHeartBeat sends the result as a POST request to the C&C server. The result is sent as a file whose name is<command_id>.png.",
        "phase": "command and control"
    },
    {
        "title": "icmp",
        "content": "Starting from version 2.4 of PowHeartBeat, HTTP was replaced by ICMP, sent packets having a timeout of six seconds and beingunfragmented. Communication through ICMP is most likely a way to evade detection.\nThere is no major change in versions 2.4 and later, but we noticed some modifications in the code:\nPowHeartBeat sends a heartbeat packet at each loop that contains the stringabcdefghijklmnopqrstuvwxyz, before requesting a command. This informs the C&C server that the backdoor is ready to receive commands. \nRequests to get commands performed by the backdoor contain the stringabcdefghijklmnop.\nHeartbeat packets have the format described in Figure 7.\nThe difference betweenclient IDandclient flagis thatclient IDdiffers in every sample whereasclient flagis the same in every sample that uses ICMP.heartbeat flagindicates that the backdoor is sending a heartbeat. The response from the C&C server has the format described in Figure 8.\nflaghere indicates whether there is a command to issue to the backdoor. Requests to get commands have the format described in Figure 9.\nNote that the backdoor's ICMP mode allows receiving an unlimited amount of data, divided into chunks, and the variablesdata length,current positionandtotal lengthare used to keep track of the transmitted data. Responses to these requests have the format described in Figure 10.\nAs in HTTP responses, the command identifier is the third byte ofdata.\nAfter seven consecutive ICMP replies with empty or inconsistently formatted content, transfers between the backdoor and C&C server are considered finished.\nConcerning the requests to send the result of the issued command to the C&C server, server mode is changed for post mode, and the final string (abcdefghijklmnop) is changed for the result data.",
        "phase": "command and control"
    },
    {
        "title": "backdoor commands",
        "content": "PowHeartBeat has various capabilities, including command/process execution and file manipulation. Table 2 lists all commands supported by the various analyzed samples.\nTable 2. PowHeartBeat command descriptions\nIn case of errors on the backdoor side, the backdoor uses a specific command identifier 0x00 in the POST request to the C&C server, thus indicating an error occurred.\nNote that before sending the information back to the C&C server, the data is gzip-compressed.",
        "phase": "execution"
    },
    {
        "title": "pngload: steganographic loader",
        "content": "PNGLoad is the second-stage payload deployed by Worok on compromised systems and, according to ESET telemetry, loaded either by CLRLoad or PowHeartBeat. While we don't see any code in PowHeartBeat that directly loads PNGLoad, the backdoor has the capabilities to download and execute additional payloads from the C&C server, which is likely how the attackers have deployed PNGLoad on systems compromised with PowHeartBeat. PNGLoad is a loader that uses bytes from PNG files to create a payload to execute. It is a 64-bit .NET executable – obfuscated with.NET Reactor– that masquerades as legitimate software. For example, Figure 11 shows the CLR headers of a sample masquerading as a WinRAR DLL.\nOnce deobfuscated, only one class is present. In this class, there is aMainPathattribute containing the directory path the backdoor searches, including its subdirectories, for files with a.pngextension, as shown in Figure 12.\nEach.pngfile located by this search ofMainPathis then checked for steganographically embedded content. First, the least-significant bit of each pixel's R (red), G (green), B (blue), and A (alpha) values are fetched and assembled into a buffer. Should the first eight bytes of that buffer match the magic number seen in Figure 13 and the next eight-byte value, control, be non-null, the file passes PNGLoad's steganographic content check. For such files, processing continues with the remainder of the buffer decrypted with a multiple-byte XOR, using the key stored in PNGLoad'sSecretKeyBytesattribute, and then the decrypted buffer is gzip-decompressed. The result is expected to be a PowerShell script, which is run immediately.\nInterestingly, operations performed by PNGLoad are logged in a file whose path is stored in the variableLogFilePath. Operations are only logged if a file is present whose path is specified by the internal variableIfLogFilePath.\nWe have not been able to obtain a sample.pngfile used along with PNGLoad, but the way PNGLoad operates suggests that it should work with valid PNG files. To hide the malicious payload, Worok uses Bitmap objects in C#, which only take pixel information from files, not the file metadata. This means that Worok can hide its malicious payloads in valid, innocuous-looking PNG images and thus hide in plain sight.",
        "phase": "command and control"
    }
]