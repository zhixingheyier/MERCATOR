[
    {
        "phase": "initial access",
        "content": "The attack begins when a user downloads and runs an HTML application (HTA) file named Player1566444384.hta. The digits in the file name differ in every attack. Analysis of Microsoft Defender ATP telemetry points to compromised advertisements as the most likely infection vector for delivering the HTA files. The mshta.exe tool (which runs when an HTA file runs) was launched with the - embedding command-line parameter, which typically indicates that the launch action was initiated by the browser. \nFurthermore, immediately prior to the execution of the HTA file, the telemetry always shows network activity towards suspicious advertisement services (which may vary slightly across infections), and a consistent access to legitimate content \nBring your own LOLBin: Multi-stage, fileless Nodersok campaign delivers rare Node.js-based malware | Microsoft Security Blog delivery service Cloudfront. Cloudfront is not a malicious entity or service, and it was likely used by the attackers exactly for that reason: because it's not a malicious domain, it won't likely raise alarms. Examples of such domains observed in several campaigns are: \nd23cy16qyloios[.]cloudfront[.]net d26klsbste71cl[.]cloudfront [.]net d2d604b63pweib[.]cloudfront [.]net d3jo79y1m6np83[.]cloudfront [.]net d1fctvh5cp9yen[.]cloudfront [.]net d3cp2f6v8pu0j2[.]cloudfront[.]net dqsiu450ekr8q[.]cloudfront [.]net \nIt's possible that these domains were abused to deliver the HTA files without alerting the browser. Another content delivery service abused later on in the attack chain is Cdn77. Some examples of observed URLs include: \nhxxps://1292172017[.]rsc [.]cdn77 [.]org/images/trpl[.]png hxxps://1292172017[.]rsc.cdn77[.]org/imtrack/strkp[.]png \nThis same strategy was also used by the Astaroth campaign, where the malware authors hosted their malware on the legitimate storage.googleapis.com service. ",
        "relationship": "1. [CoT]: The text states that the user downloads the HTA file, indicating a process-to-file relationship where the process is the user and the verb is downloads. [Relationships]: <process:user,downloads,file:Player1566444384.hta>. \n2. [CoT]: The text mentions that mshta.exe was launched with the -embedding parameter, showing a process-to-process relationship where the process is mshta.exe and the verb is launches. [Relationships]: <process:mshta.exe,launches,process:Player1566444384.hta>. \n3. [CoT]: The telemetry shows network activity towards suspicious advertisement services, indicating a process-to-socket relationship where the process is mshta.exe and the verb is connects to. [Relationships]: <process:mshta.exe,connects to,socket:suspicious advertisement services>. \n4. [CoT]: The telemetry mentions access to the legitimate content delivery service Cloudfront, showing a process-to-socket relationship where the process is mshta.exe and the verb is connects to. [Relationships]: <process:mshta.exe,connects to,socket:Cloudfront>. \n5. [CoT]: The text describes that the same strategy was used by hosting malware on the service storage.googleapis.com, indicating a process-to-socket relationship where the process is mshta.exe and the verb is connects to. [Relationships]: <process:mshta.exe,connects to,socket:storage.googleapis.com>. \n6. [CoT]: The text states that the malware authors hosted their malware on Cdn77, showing a process-to-socket relationship where the process is mshta.exe and the verb is downloads. [Relationships]: <process:mshta.exe,downloads,socket:Cdn77>. "
    },
    {
        "phase": "command and control",
        "content": "When the HTA file runs, it tries to reach out to a randomly named domain to download additional JavaScript code. The domains used in this first stage are shortlived: they are registered and brought online and, after a day or two (the span of a typical campaign), they are dropped and their related DNS entries are removed. This can make it more difficult to investigate and retrieve the components that were delivered to victims. Examples of domains observed include: \nDu0ohrealgeek[.]org – active from August 12 to 14 Hi5urautopapyrus[.]org – active from April 21 to 22 Ex9ohiamistanbul[.]net – active from August 1 to 2 Eek6omyfilmbiznetwork[.]org – active from July 23 to 24 \nThis stage is just a downloader: it tries to retrieve either a JavaScript or an extensible style language (XSL) file from the command-and-control (C&C) domain. These files have semi-random names like 1566444384.js and 1566444384.xsl, where the digits are different in every download. After this file is downloaded and runs, it contacts the remote C&C domain to download an RC4-encrypted file named 1566444384.mp4 and a decryption key from a file named 1566444384.flv. When decrypted, the MP4 file is an additional JavaScript snippet that starts PowerShell: \na.Environment('Process')(\"deadbeef\") $=$ \"iex([Text.Encoding]::ASCII.GetStr a.Run(\"\\\"\"+p+\"\\\" -Enc LgAoACIAewAwAHOAewAxAHOAIgAgACOAZgAnAGkAJwAsACcAZQE \nInterestingly, it hides the malicious PowerShell script in an environment variable named \"deadbeef\" (first line), then it launches PowerShell with an encoded command (second line) that simply runs the contents of the \"deadbeef\" variable. This trick, which is used several times during the infection chain, is usually employed to hide the real malicious script so that it does not appear in the command-line of a PowerShell process. ",
        "relationship": "1. [CoT]: The HTA file (process) reaches out to randomly named domains (socket) to download additional JavaScript code. [Relationships]: <process:HTA file, reaches out to, socket:domain>. \n2. [CoT]: The HTA file (process) downloads a JavaScript or XSL file from the C&C domain (socket). [Relationships]: <process:HTA file, downloads, socket:file>. \n3. [CoT]: The downloaded file (process) contacts the remote C&C domain (socket) to download an RC4-encrypted file. [Relationships]: <process:downloaded file, contacts, socket:C&C domain>. \n4. [CoT]: The downloaded file (process) downloads a decryption key from another file (socket). [Relationships]: <process:downloaded file, downloads, socket:file>. \n5. [CoT]: PowerShell (process) runs the contents of the \"deadbeef\" environment variable (registry key). [Relationships]: <process:PowerShell, runs, reg:environment variable>. "
    },
    {
        "phase": "execution",
        "content": "Nodersok's infection continues by launching several instances of PowerShell to download and run additional malicious modules. All the modules are hosted on the C&C servers in RC4-encrypted form and are decrypted on the fly before they run on the device. The following steps are perpetrated by the various instances of PowerShell: \nDownload module.avi, a module that attempts to: Disable Windows Defender Antivirus Disable Windows updates \nBring your own LOLBin: Multi-stage, fileless Nodersok campaign delivers rare Node.js-based malware | Microsoft Security Blog Run binary shellcode that attempts elevation of privilege by using autoelevated COM interface   \nDownload additional modules trpl.png and strkp.png hosted on a Cdn77 service   \nDownload legitimate node.exe tool from the official nodejs.org website   \nDrop the WinDivert packet capture library components WinDivert.dll, WinDivert32.sys, and WinDivert64.sys   \nExecute a shellcode that uses WinDivert to filter and modify certain outgoing packets   \nFinally, drop the JavaScript payload along with some Node.js modules and libraries required by it, and run it via node.exe \nThis last JavaScript is the actual final payload written for the Node.js framework that turns the device into a proxy. This concludes the infection, at the end of which the network packet filter is active and the machine is working as a potential proxy zombie. When a machine turns into a proxy, it can be used by attackers as a relay to access other network entities (websites, C&C servers, compromised machines, etc.), which can allow them to perform stealthy malicious activities. ",
        "relationship": "1. [CoT]: The text states that PowerShell is used to download modules from C&C servers, indicating a process-to-socket relationship. [Relationships]: <process:PowerShell,download,socket:C&C servers>. \n2. [CoT]: The text mentions that modules are decrypted on the fly before they run, implying a process-to-file relationship where PowerShell decrypts the RC4-encrypted modules. [Relationships]: <process:PowerShell,decrypt,file:RC4-encrypted modules>. \n3. [CoT]: The text describes PowerShell running binary shellcode, indicating a process-to-file relationship. [Relationships]: <process:PowerShell,run,file:binary shellcode>. \n4. [CoT]: The text states that PowerShell downloads additional modules from a Cdn77 service, showing a process-to-socket relationship. [Relationships]: <process:PowerShell,download,socket:Cdn77 service>. \n5. [CoT]: The text mentions the download of a legitimate node.exe tool from the official nodejs.org website, indicating a process-to-socket relationship. [Relationships]: <process:PowerShell,download,socket:nodejs.org>. \n6. [CoT]: The text lists the dropping of files, including WinDivert.dll, WinDivert32.sys, and WinDivert64.sys, showing a process-to-file relationship. [Relationships]: <process:PowerShell,drop,file:WinDivert.dll>. \n7. [CoT]: The text continues with the dropping of WinDivert32.sys and WinDivert64.sys, adding more file entities to the relationship list. [Relationships]: <process:PowerShell,drop,file:WinDivert32.sys>. \n8. [CoT]: The text concludes with the execution of shellcode using WinDivert, indicating a process-to-process relationship. [Relationships]: <process:shellcode,use,process:WinDivert>. \n9. [CoT]: The text describes the final step of dropping the JavaScript payload and Node.js modules, showing a process-to-file relationship. [Relationships]: <process:PowerShell,drop,file:JavaScript payload>. \n10. [CoT]: The text also mentions the dropping of Node.js modules and libraries, adding more file entities to the relationship list. [Relationships]: <process:PowerShell,drop,file:Node.js modules and libraries>. \n11. [CoT]: The text concludes with the running of the JavaScript payload via node.exe, indicating a process-to-file relationship. [Relationships]: <process:node.exe,run,file:JavaScript payload>. "
    },
    {
        "phase": "execution",
        "content": "This is not the first threat to abuse Node.js. Some cases have been observed in the past (for example this ransomware from early 2016). However, using Node.js is a peculiar way to spread malware. Besides being clean and benign, Node.exe also has a valid digital signature, allowing a malicious JavaScript to operate within the context of a trusted process. The JavaScript payload itself is relatively simple: it only contains a set of basic functions that allows it to act as a proxy for a remote entity. \nthis.send $\\equiv$ function(ddd) this.close $=$ function() 1 function backconnect (lurl) const socket $=$ $()=>1$ $=$ 1); 1); else 1); \nBring your own LOLBin: Multi-stage, fileless Nodersok campaign delivers rare Node.js-based malware | Microsoft Secu The code seems to be still in its infancy and in development, but it does work. It has two purposes: \n1. Connect back to the remote C&C, and   \n2. Receive HTTP requests to proxy back to it \nIt supports the SOCKS4A protocol. While we haven't observed network requests coming from attackers, we wrote what the Node.js-based C&C server application may look like: a server that sends HTTP requests to the infected clients that connect back to it, and receives the responses from said clients. we slightly modified the malicious JavaScript malware to make it log meaningful messages, ran a JavaScript server, ran the JavaScript malware, and it proxied HTTP requests as expected: \nThe server starts, then the client starts and connects to it. In response, the server sends a HTTP request (using the Socks4A protocol) to the client. The request is a simple HTTP GET. The client proxies the HTTP request to the target website and returns the HTTP response (200 OK) and the HTML page back to the server. This test demonstrates that it's possible to use this malware as a proxy. ",
        "relationship": "1. [CoT]: The text states that the JavaScript payload contains functions that allow it to act as a proxy for a remote entity, which implies interacting with a socket for communication. [Relationships]: <process:JavaScript,payload,connect,socket:unknown>. \n2. [CoT]: The code defines a function 'backconnect' that takes a parameter 'lurl' which is a URL, indicating a socket interaction. [Relationships]: <process:JavaScript,backconnect,connect,socket:lurl>. \n3. [CoT]: The code defines a constant 'socket' which is a function that implies socket interaction for communication. [Relationships]: <process:JavaScript,socket,create,socket:unknown>. \n4. [CoT]: The text describes the malware connecting back to the remote C&C, indicating a socket interaction. [Relationships]: <process:malware,connect,socket:C&C>. \n5. [CoT]: The text mentions the malware receiving HTTP requests to proxy back to the remote entity, indicating a socket interaction for incoming requests. [Relationships]: <process:malware,receive,socket:HTTP requests>. \n6. [CoT]: The text describes the server sending HTTP requests to infected clients, indicating a socket interaction for outgoing requests. [Relationships]: <process:server,sends,socket:HTTP requests>. \n7. [CoT]: The text mentions the server receiving responses from infected clients, indicating a socket interaction for incoming responses. [Relationships]: <process:server,receives,socket:responses>. \n8. [CoT]: The text describes the client proxying the HTTP request to the target website, indicating a socket interaction for outgoing proxying. [Relationships]: <process:client,proxies,socket:target website>. \n9. [CoT]: The client returns the HTTP response and HTML page back to the server, indicating a socket interaction for outgoing returning. [Relationships]: <process:client,returns,socket:HTTP response and HTML page>. "
    },
    {
        "phase": "execution",
        "content": "As mentioned earlier, there exist other variants of this malware. For example, we found one named 05sall.js (possibly an earlier version). It's similar in structure to the one described above, but the payload was not developed in Node.js (rather it was an executable). Furthermore, beyond acting as a proxy, it can run additional commands such as update, terminate, or run shell commands. \nThe malware can also process configuration data in JSON format. For example, this configuration was encoded and stored in the registry in an infected machine: \nThe configuration is an indication of the modular nature of the malware. It shows the names of two modules being used in this infection (named block_av_01 and all_socks_05). ",
        "relationship": "1. [CoT]: The text mentions that the malware can process configuration data in JSON format, specifically referencing an encoded configuration stored in the registry. This indicates that the malware (process) interacts with the registry (registry key) to retrieve configuration data.   [Relationships]: <process:05sall.js,process,read,registry:configuration data in JSON format>. \n2. [CoT]: The text states that the malware (process) can run additional commands, implying interaction with other processes. While specific commands are not mentioned, the general capability is noted.   [Relationships]: <process:05sall.js,process,run,process:additional commands>. \n3. [CoT]: The text describes the malware's ability to run additional commands, specifying one type as shell commands. This indicates an interaction between the malware (process) and potential shell processes to execute these commands.   [Relationships]: <process:05sall.js,process,run,process:shell commands>. \n4. [CoT]: The text mentions that the malware (process) named 05sall.js can run additional commands, one of which is terminate. This indicates an interaction where the malware process terminates other processes.   [Relationships]: <process:05sall.js,process,terminate,process:additional commands>. \n5. [CoT]: The text states that the malware (process) can proxy data through a socks5 proxy, indicating an interaction where the process sends data through the proxy (socket).   [Relationships]: <process:05sall.js,process,proxy,socket:socks5 proxy>. "
    },
    {
        "phase": "command and control",
        "content": "At this point in the analysis, there is one last loose end: what about the WinDivert packet capture library? We recovered a shellcode from one of the campaigns. This shellcode is decoded and run only in memory from a PowerShell command. It installs the following network filter (in a language recognized by WinDivert): \noutbound and ip and tcp.syn and tcp.ack $\\mathfrak{L}=~\\mathfrak{1}$ and loopback $\\scriptstyle=={\\widehat{\\mathbf{\\theta}}}$ \nThis means Nodersok is intercepting packets sent out to initiate a TCP connection. Once the filter is active, the shellcode is interested only in TCP packets that match the following specific format: \nThe packet must have standard Ethernet, ${|\\mathsf{P},}$ and 20 bytes TCP headers, plus an additional 20 bytes of TCP extra options. The options must appear exactly in the order shown in the image above: \n02 04 XX XX – Maximum segment size 01 – No operation ? 03 03 XX – Windows Scale 04 02 – SACK permitted 08 0A XX XX XX XX XX XX XX XX – Time stamps \nIf packets matching this criterion are detected, Nodersok modifies them by moving the \"SACK Permitted\" option to the end of the packet (whose size is extended by four bytes), and replacing the original option bytes with two \"No operation\" bytes. \nIt's possible that this modification benefits the attackers; for example, it may help evade some HIPS signatures. ",
        "relationship": "1. [CoT]: The text states that the WinDivert packet capture library is used to recover shellcode, indicating a process-to-file relationship. [Relationships]: <process:WinDivert packet capture library,recovers,file:shellcode>. \n2. [CoT]: The shellcode is decoded and run only in memory from a PowerShell command, showing a process-to-file relationship. [Relationships]: <process:PowerShell,decodes and runs,file:shellcode>. \n3. [CoT]: The shellcode installs the provided network filter, which is a string of rules in a language recognized by WinDivert, indicating a process-to-file relationship. [Relationships]: <process:shellcode,installs,file:network filter>. \n4. [CoT]: The text mentions that Nodersok is intercepting packets, showing a process-to-socket relationship. [Relationships]: <process:Nodersok,intercepts,socket:packets>. \n5. [CoT]: Nodersok modifies packets by rearranging TCP options, indicating a process-to-socket relationship. [Relationships]: <process:Nodersok,modifies,socket:packets>. "
    }
]