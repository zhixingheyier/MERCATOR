[
    {
        "phase": "initial access",
        "content": "The Ursnif sample from the alert comes from a Microsoft Word document containing a malicious VBA macro. The document is straightforward, simply displaying an image that asks the user to enable macros. If macros are already permitted, the macro is executed automatically when opening the document via the AutoOpen function. \nThe macro is mostly obfuscated code that executes math functions on data that does not relate to the next stage. There is only one line in the macro that is important to executing the next stage, ultimately executing PowerShell. \nInteraction@.Shell RTrim(LTrim(Shapes(\"j6h1cf\").AlternativeText)), 84 \\* 2 + -168 \nThis line accesses the AlternativeText property of the Shapes object \"j6h1cf.\" The value of this property is the malicious PowerShell command, which is subsequently executed by the Shell function. The PowerShell command is base64 encoded, and is another PowerShell command that downloads Ursnif. Specifically, it downloads an executable from its C2 to the AppData directory and executes it. Note, this is where the Exploit Prevention engine stops executing the downloaded file and provides us with alerts to investigate. ",
        "relationship": "1. [Relationships]: <process:Microsoft Word,executes,process:VBA macro>. \n2. [Relationships]: <process:Microsoft Word,executes,process:PowerShell>. \n3. [Relationships]: <process:PowerShell,downloads,socket:C2>. \n4. [Relationships]: <process:PowerShell,executes,file:executable>. "
    },
    {
        "phase": "execution",
        "content": "After the Ursnif executable is downloaded and executed, registry data is created that is important for the next stage of execution. \nThe PowerShell command for the next stage of execution resides in the value of the APHohema key, as shown in the image above. \nThis command uses Windows Management Instrumentation Command-line (WMIC) to execute PowerShell, which extracts the value of the Authicap key to execute it. The value of the Authicap key is a hexadecimal-encoded PowerShell command. The WMIC command makes use of /output:clipboard as a way to hide the normal output of process creation that is printed when creating a process with WMIC. \nC:\\WINDOWS\\system32\\wbem\\wmic.exe /output:clipboard process call create \"powershell -w hidden iex([System.Text.Encoding]::ASCII.GetString((get-itemproperty 'HKCU:\\Software\\AppDataLow\\Software\\Microsoft\\236FF8AB-268A-4D1B-4807- ",
        "relationship": "1. [Relationships]: <process:Ursnif,created,reg:APHohema>. \n2. [Relationships]: <process:WMIC,executes,process:PowerShell>. \n3. [Relationships]: <process:WMIC,extracts,reg:Authicap>. \n4. [Relationships]: <process:WMIC,creates,process:powershell>. \n5. [Relationships]: <process:powershell,executes,file:HKCU:\\Software\\AppDataLow\\Software\\Microsoft\\236FF8AB-268A-4D1B-4807-  000000000000>. "
    },
    {
        "phase": "execution",
        "content": "The hexadecimal-encoded PowerShell command executed from Authicap decodes to a large PowerShell command, of which the most interesting part is base64-encoded. There are three parts to the command. The first part creates a function that is later used to decode base64 encoded PowerShell. The second part creates a byte array containing a malicious DLL. The third part executes the base64 decode function created in the first part, with a base64 encoded string as the parameter to the function. The returned decoded PowerShell is subsequently executed by the shorthand Invoke-Expression (iex) function. \nThe decoded base64 PowerShell that is executed by iex is used to execute an Asynchronous Procedure Call (APC) Injection. \nThe first part of the command creates two variables that import kernel32.dll. In this case, the variables are \\$igaoctlsc and \\$gdopgtvl, as seen being established by the Add-Type cmdlet. \nThe APIs imported from kernel32 are: \nGetCurrentProcess VirtualAllocEx GetCurrentThreadID QueueUserAPC ",
        "relationship": "1. [Relationships]: <process:PowerShell,executes,process:Authicap>. \n2. [Relationships]: <process:PowerShell,creates,file:kernel32.dll>. \n3. [Relationships]: <process:PowerShell,imports,file:kernel32.dll>. \n4. [Relationships]: <process:PowerShell,executes,process:Invoke-Expression>. "
    },
    {
        "phase": "defense evasion",
        "content": "SleepEx \nAfter the imports are established, the last portion is a single line that performs the APC Injection via the QueueUserAPC API. Here is the simplified form of that single line, with more readable formatting and normalized variable names. \nThe injection starts by allocating memory for the malicious DLL with VirtualAllocEx, targeting the current process. If the allocation is successful, it then copies the malicious DLL into the newly allocated memory with Copy. Once that is completed, QueueUserAPC is executed, specifying the current thread within its process. This creates a user-mode APC and queues it within the thread. To execute the malicious DLL from the APC queue, the thread needs to enter an alertable state. SleepEx is used to trigger an alertable state completing the APC injection, by specifying 1 (True) for its second parameter which is bAlertable. ",
        "relationship": "1. [Relationships]: <process:SleepEx,allocates,process:VirtualAllocEx>. \n2. [Relationships]: <process:SleepEx,copies,file:malicious DLL>. \n3. [Relationships]: <process:SleepEx,executes,process:QueueUserAPC>. \n4. [Relationships]: <process:SleepEx,triggers,process:current thread>. "
    },
    {
        "phase": "exfiltration",
        "content": "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT %u.%u%s) \nThe CAB files containing the data to be exfiltrated are stored in %TEMP%, with the filename format being four hexadecimal characters and a .bin extension. As Ursnif logs data to be exfiltrated, it creates CAB files to store the data with the built-in makecab.exe command. The command targets a created MakeCab directive file in the %TEMP% directory. The images below shows the created CAB files in %TEMP% and the MakeCab directives. \nInside the created CAB files are plaintext data in the format: <Current Date and Time> <Process Path> <Window Text> <Keystrokes Logged> ",
        "relationship": "1. [Relationships]: <process:Ursnif,creates,file:%TEMP%\\[four hexadecimal characters].bin>. \n2. [Relationships]: <process:Ursnif,logs,file:%TEMP%\\[MakeCab directive file]>. \n3. [Relationships]: <process:Ursnif,uses,process:makecab.exe>. \n4. [Relationships]: <process:makecab.exe,targets,file:%TEMP%\\[MakeCab directive file]>. \n5. [Relationships]: <process:Ursnif,stores,file:%TEMP%\\[CAB files]>. "
    }
]