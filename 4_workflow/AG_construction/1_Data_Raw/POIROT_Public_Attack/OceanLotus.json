[
    {
        "title": "OCEANLOTUS: OLD TECHNIQUES, NEW BACKDOOR",
        "content": "The OceanLotus group, also known as APT32 and APT-C-00, is infamous for its campaigns targeting the eastern part of Asia. A great deal of research about this group was published last year, including papers such as those from CyberReason, a lengthy global view from FireEye and the watering-hole explanation from Volexity. We see that this group keeps updating their backdoors, infrastructure, and infection vectors. \nOceanLotus continues its activity particularly targeting company and government networks in East-Asian countries. A few months ago, we discovered and analyzed one of their latest backdoors. Several tricks are being used to convince the user to execute the backdoor, to slow down its analysis and to avoid detection. These techniques will be discussed in detail in this blog post. "
    },
    {
        "title": "Technical analysis",
        "content": "The whole process of installation and execution relies heavily on multiple layers of obfuscation such as decryption of payloads, PE reconstruction and loading shellcode, and side-loading techniques. The last technique was previously described in a previous ESET research article about Korplug. "
    },
    {
        "title": "Execution flow overview",
        "content": "The attack is split in two parts: the dropper and backdoor launcher. Each step of each part of the process will be explained in detail in its respective section. The following two diagrams briefly summarize the general flow of execution of the malware. \nThe dropper part has the following flow of execution: \nThe backdoor part has the following execution flow: "
    },
    {
        "title": "A quick word on control flow obfuscation",
        "content": "Almost all of these components are obfuscated. The obfuscation is based on pairs of complementary conditional jump instructions. Every form is used: JZ/JNZ, JP/JNP, JO/JNO, etc, each pair jumping to the same target. The sequence is interleaved with junk code, which makes use of the stack pointer, but does not change the conditional flag's value. This means it will always end up in the same branch. This causes problems during decompilation due to the use of positive stack pointer values. \nMoreover, some basic blocks push one address on the stack, then end with a JMP/CALL while other basic blocks push two addresses then end with a RET instruction. The second push is the function to call and the first one is the address of the next basic block to jump to. This creates basic blocks with no parents. \nThe resulting combination of these two obfuscation techniques creates \"beautiful\" graphs: \nThe junk code is pretty easy to spot and once the scheme is known, it can be ignored when analysing the samples. "
    },
    {
        "title": "Stage 1-2 The decoy document and shell code",
        "content": "Over the past few months, a number of decoy documents have been used. One of them was a fake TrueType font updater for the Roboto Slab regular font. This choice of font seems a bit odd since it does not support a lot of East-Asian languages. \nWhen executed, this binary decrypts its resource (XOR with a 128-byte, hardcoded key) and decompresses the decrypted data (LZMA). The legitimate RobotoSlab-Regular.ttf (SHA1:912895e6bb9e05af3a1e58a1da417e992a71a324) file is written into the %temp% folder and run via Win32 API function ShellExecute. \nThe shellcode decrypted from the resource is executed. After its execution, the fake font updater drops another application whose sole purpose is to delete the dropper. This \"eraser\" application is dropped as %temp%\\[0-9].tmp.exe. \nThe shellcode is a custom PE loader. It recreates an executable in memory: it decrypts all the sections and computes the necessary relocations and other offsets. The shellcode retrieves three Windows API functions: VirtualAlloc, RtlMoveMemory and RtlZeroMemory. \nThe RtlZeroMemory function is heavily used to zero-out fields in the PE header. Relying on automatic memory dumping will not work since the MZ/PE headers are broken. \nThe shellcode calls the entry-point function of the decrypted PE and then the DLLEntry export function. "
    },
    {
        "title": "Stage 3 Real Dropper, {103004A5-829C-418E-ACE9-A7615D30E125}.dll",
        "content": "This executable decrypts its resource using the AES algorithm with CBC mode via the Windows API. The size of the hardcoded key is 256 bits. After decryption, the data are decompressed (LZMA algorithm). \nIf the process is running with administrator privileges, then the malware achieves persistence by creating a service, else the classic Windows \"Run\" registry key is used (HKCU\\SOFTWARE\\Microsoft\\ Windows\\CurrentVersion\\Run;DeviceAssociationService;rastlsc.exe). \nIf the dropper is executed with administrator privileges, then it tries to write the following files in the C:\\Program Files\\Symantec\\Symantec Endpoint Protection\\12.1.671.4971.104a\\ DeviceAssociationService\\ folder else it writes them in the %APPDATA%\\Symantec\\Symantec Endpoint Protection\\12.1.671.4971.104a\\DeviceAssociationService\\ folder: \n•\t rastlsc.exe (SHA1:2616da1697f7c764ee7fb558887a6a3279861fac, copy of legitimate Symantec Network Access Control application, dot1xtra.exe)   \n•\t SyLog.bin (SHA1:5689448b4b6260ec9c35f129df8b8f2622c66a45, encrypted backdoor)   \n•\t rastls.dll (SHA1:82e579bd49d69845133c9aa8585f8bd26736437b,malicious DLL sideloaded by rastlsc.exe) \nThe path changes from sample to sample but the pattern is similar. Depending on its privileges, the malware drops the files in %ProgramFiles% or %appdata%. We've also seen: \n•\t \\Symantec\\CNG Key Isolation\\ \n•\t \\Symantec\\Connected User Experiences and Telemetry\\ \n•\t \\Symantec\\DevQuery Background Discovery Broker Tasks\\ \nThese paths are used by various Symantec products. \nAfter achieving persistence and dropping the executable, the legitimate Symantec executable, rastlsc.exe, is executed using CreateProcessW. \nWe've also seen another version ({BB7BDEC9-B59D-492E-A4AF-4C7B1C9E646B}.dll), which executes rastlsc.exe with the parameter krv. Its meaning is discussed below. "
    },
    {
        "title": "Backdoor component: rastlsc.exe side-loading",
        "content": "The OceanLotus group uses an old and publicly known technique on one of the Symantec product's executable files. The trick, here, is to take advantage of the library loading process of a legitimate and signed executable by writing a malicious library inside the same folder. This way it will make malicious behaviors look legitimate because these actions are made by the trusted executable process. \nAs mentioned earlier, the legitimate executable rastlsc.exe is dropped and executed.   \nThis executable imports the rastls.dll file, which in this case contains the malicious payload. \nSide loading was also observed using other legitimate, signed executables including mcoemcpy.exe from McAfee, which loads McUtil.dll. This technique has also been used by PlugX before. This also got the attention of the Vietnam CERT (Vietnamese language). "
    },
    {
        "title": "Stage 1 Library side-loading, rastls.dll",
        "content": "As mentioned earlier, the legitimate executable rastlsc.exe is dropped and executed. \nThis executable imports the rastls.dll file, which in this case contains the malicious payload. \nThe internal name of this dll is {7032F494-0562-4422-9C39-14230E095C52}.dll but we've seen other versions like {5248F13C-85F0-42DF-860D-1723EEAA4F90}.dll. All exported functions lead to the execution of the same function. \nThis export tries to read the SyLog.bin file located inside the same folder. Other versions tried to open the file OUTLFLTR.DAT. If that file exists, it is decrypted using AES in CBC mode with a hardcoded, 256-bit key and then decompressed (LZMA compression). \nThe McUtil.dll variant uses a different technique. At first glance, it looks as if like the main function does nothing malicious, but in fact it replaces the .text section of the legitimate mcoemcpy.exe, a side-loaded binary. It generates shellcode whose purpose is to call the function reading the encrypted stage-two  shellcode in the mcscentr.adf file. \nThe following pseudocode is used to create the shellcode: \nThe result is the following assembly listing: "
    },
    {
        "title": "Stage 2 to Stage 4 Shellcode, Launcher and Shellcode again",
        "content": "The shellcode decrypts and loads the library {E1E4CBED-5690-4749-819D-24FB660DF55F}.dll.   \nThe library retrieves its resource and tries to start the service \"DeviceAssociationService\".   \nThe decrypted data also contains shellcode. The latter decrypts the final layer: the backdoor. \nThe variant {92BA1818-0119-4F79-874E-E3BF79C355B8}.dll checks whether rastlsc.exe was executed with krv as the first parameter. If so, then a job is created and rastlsc.exe is executed again, but without the parameter. "
    },
    {
        "title": "Stage 5 The backdoor, {A96B020F-0000-466F-A96D-A91BBF8EAC96}.dll",
        "content": "The malware retrieves the first 10 bytes of the username (UTF-16), XORs it with the 3-letter UTF-16 mutex_encoding_str string, and encodes it in hex. The result is used as a mutex name. For instance, for a user whose name starts with abc and the key being vwx, the following mutex will be created: \\Sessions\\1\\BaseNamedObjects\\170015001b. \nThe backdoor includes a PE loader that loads the library HTTPProv.dll in memory, calls its entrypoint and then calls the export function named CreateInstance. "
    },
    {
        "title": "Communication",
        "content": "The backdoor uses a classic TCP communication protocol over port 25123. In order to retrieve the server IP address, the backdoor first creates a particular DNS query. \nThe malware chooses between one of the three domains from the configuration and adds a custom sub-domain generated using two values. The first value is the computer name up to a length of 16 bytes. The second value is the 4-byte version ID. The following Python 2 code implements the encoding algorithm : \nFor instance, if the computer name is random-pc and the version ID is 0x0a841523 then the following domain could be created: \nniggmhggmeggmkggmfggmdggidggngggmjgg.ijhlokga.dwarduong[.]com \nThe following regular expression could be used to flag a C&C server for this backdoor: \n[ghijklmnopabcdef]{4-60}\\.[ghijklmnopabcdef]{8}\\.[a-z]+\\.[a-z]+ \nIf an IP address is resolved for this particular domain, then the malware tries to establish a connection on TCP port 25123. Each sample has three different domain names it can use to find its C&C server. \nAll communication is encrypted using RC4 and compressed with LZMA. It is possible to decrypt the traffic because the key is prepended to the packets. The format is: \n[RC4 key (4 bytes)][encrypted data] \nEach byte of the key is generated using the rand function. Once the packet is decrypted and decompressed, the data follow the format: \n[dw:unknown][dw:unknown][dw:command number][dw:size of data][dw:unknown] [dw:data] \nThe first time the client connects to the server, a UUID is returned and used as a session ID. The latter is stored in the registry key as binary data: HKCU\\SOFTWARE\\Classes\\ AppXc52346ec40fb4061ad96be0e6cb7d16a\\DefaultIcon \nAs mentioned earlier, the backdoor also contains a library called HTTPprov. This library is an alternative way, as a backup, to communicate with the server as a backup. This DLL sends a POST request over the HTTP protocol to communicate. It also supports HTTPS and the usage of a SOCKS5, SOCKS4a or SOCKS4 proxy. The library is statically linked with libcurl. \nOnce its initialization is done, the following registry key is created to instruct the backdoor to use HTTP in future communication with the C&C server: HKCU\\SOFTWARE\\Classes\\ CLSID{E3517E26-8E93-458D-A6DF-8030BC80528B}. \nA generic user agent is used: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0;   \nTrident/4.0). \nThe most distinctive characteristic of this library is the custom URI encoding algorithm. The resource part of the URI is created using the following pseudocode: \nNOTE: For clarity, the length-checking part has been removed from the snippet. \nFrom this generated string, two numbers are computed based on the custom checksum to obtain a URI: \nBy adding the URI generator of the HTTPprov library, the following URL could be generated: \nhXXp://niggmhggmeggmkggmfggmdggidggngggmjgg.ijhlokga.aisicoin[.]com/ 13/139756-Ses-Ufali-L "
    },
    {
        "title": "Commands",
        "content": "After receiving its SESSIONID, the backdoor does a fingerprint of the system. The packet is built in this fashion: \nHere's an example of a fingerprint of a system: \nThis is a full-featured backdoor that offers its operators many capabilities, such as file, registry and process manipulation, loading additional components, and performing a system fingerprint. Here's the list of supported commands: "
    },
    {
        "title": "CONCLUSION",
        "content": "Once again, OceanLotus shows that the team is active and continues to update its toolset. This also demonstrates its intention to remain hidden by picking its targets, limiting the distribution of their malware and using several different servers to avoid attracting attention to a single domain or IP address. The encryption of the payload, together with the side-loading technique – despite its age – is a good way to stay under the radar, since the malicious activities look like they come from the legitimate application. "
    }
]