[
    {
        "title": "The Story of a Ransomware Turning into an Accidental Wiper",
        "content": "In the last issue of ourRansomware Roundupseries, we discussed a publicly available open-source ransomware toolkit called Cryptonite. As part of that investigation, we also discovered a Cryptonite sample in the wild that never offers the decryption window, instead acting as a wiper. We recently saw an increase in ransomware intentionally turned into wiper malware, primarily as part of a political campaign. So in this post, we take a closer look at the Cryptonite wiper sample.\nAffected platforms:Microsoft WindowsImpacted parties:Microsoft Windows UsersImpact:Encrypts files on the compromised machine without offering decryptionSeverity level:High"
    },
    {
        "title": "Cryptonite Summary",
        "content": "Let's start with the good news: since the release of our Ransomware Roundup and with the help of the security community, the Cryptonite source code was removed from GitHub (Figure 1).\nAnd even though the original repository was forked 41 times on GitHub, all of these were also removed.\nLooking at the contributions of the repository, we can see that it was primarily developed by the CYBERDEVILZ group, with the help of only a few contributors (Figure 2).\nCryptonite's ransomware sample only implements a barebones ransomware functionality. The operator can configure a few things, such as an exclusion list, server URL, email address, andbitcoin wallet. However, the encryption and decryption are very simple and not robust. It also does not provide any of the currently typical (but more complex) ransomware features, including:\n- Windows Shadow Copy removal- File unlocking for a more thorough impact- Anti-analysis- Defensive evasion (AMSI bypass, disabling event logging, etc.)\nEven though this ransomware variant provided an easy entry for newcomers to the ransomware business, it isn't a serious tool."
    },
    {
        "title": "Ransomware turned into a wiper",
        "content": "The sample we discuss in this post has the SHA1 hash of a891e774eeb9671ff2dd1334e1628ba18fb60575. We started to dig deeper into this sample because we have been actively hunting for wiper malware in the wild, and this sample acted like one.\nWhether executed manually or in a Sandbox, it seems to function correctly at first. It shows a progress bar (Figure 3) as it pretends to be a software update. The progress, however, actually represents the progress of encryption. And, of course, it encrypts files as expected.\nHowever, it never displays the window that allows the victim to start the decryption process with the decryption key. Of course, there could be many reasons for this. But one possibility is that the threat actor intentionally turned this ransomware into a wiper. To validate this assumption, we turned our attention to static analysis."
    },
    {
        "title": "Static Analysis",
        "content": "We knew from the source code on GitHub that the sample is a python program bundled withpyinstallerinto an executable. I wrote ablog postabout how to unpack such executables. Using those techniques, we unpacked the program withpyinstxtractorand decompiled it with uncompyle6. To determine whether the actor made any changes in the code, we created a diff between the decompiled code and the malware template from GitHub (Figure 4).\nYou can see the analyzed sample on the left and the template from GitHub on the right. It looks like five lines were removed while the program enumerates the filesystem.\nHowever, after further review of the code, it seemed that removing those five lines would completely break the program's functionality. For example, Line 87 on the right is the only place where thefileListsvariable is populated. It should contain all the files that will later be encrypted. This means that the code on the left should not encrypt any files. This was confirmed by testing the code separately.\nTo check whether our tools are lying to us (spoiler: they did), we looked at theCryptonite.pyc(the file we used to decompile the code) on a python bytecode level. This is the intermediate language python uses in .pyc files. Figure 5 shows the assembly-like bytecode of thefindFiles()function.\nIn Figure 5, between line 396 and line 412, we see the code from line 85 to line 87 shown on the right side of Figure 4. This indicates that the code is there but somehow got lost in the decompilation process. This is a lesson learned in reverse engineering: always double-check when something isn't right.\nApart from this, there was no functional difference between the sample's code and the template."
    },
    {
        "title": "Dynamic Analysis",
        "content": "To investigate further, we turned to dynamic analysis. After several executions, we found the tool that gave us answers: running the sample incmd.exe. There we can see the python exceptions once the program crashes, as shown in Figure 6.\nThe traceback shows that the ransomware fails when it tries to use thetkinterlibrary in thewarningScreen()function. At this point in this ransomware, the encryption process has already finished. ThewarningScreen()should show the ransom note and allow the victim to start the decryption."
    },
    {
        "title": "No Way to Recover",
        "content": "We can now see that the ransomware wasnotintentionally turned into a wiper. Instead, the lack of quality assurance led to a sample that did not work correctly. The problem with this flaw is that due to the design simplicity of the ransomware if the program crashes-or is even closed-there is no way to recover the encrypted files.\nFirst, there is no way to run the program in a 'decryption-only' mode. Every time it is executed, it re-encrypts everything with a different key before offering the decryption to the victim.\nSecond, as shown in Figure 7, a key is generated in line 10 to instantiate a Fernet instance for cryptography. This key is the real cryptographic key. However, it is never used again in the code and is not sent to the operator.\nIn line 12, another random number is generated. In the constructor of theCryptoniteclass, thedkrptvalue is used to populate thedecryptPleasevariable (Figure 9).\nLater, this key is sent to the operator (Figure 8). This is the key provided to the victim if a ransom payment is made.\nTo check whether the victim has the correct key, the submitted value is compared to thedecryptPlease, as shown in Figure 10.\nFor the actual decryption, the Fernet instance that has already stored the initial generated key is used.\nThis leads to the problem that the actual encryption key vanishes when this program ends. Not even the operator will have access to it. In the case reviewed in this analysis, when the program crashes due to an exception, there is no way to recover the encrypted data."
    },
    {
        "title": "Conclusion",
        "content": "This sample demonstrates how a ransomware's weak architecture and programming can quickly turn it into a wiper that does not allow data recovery. Although we often complain about the increasing sophistication of ransomware samples, we can also see that oversimplicity and a lack of quality assurance can also lead to significant problems. On the positive side, however, this simplicity, combined with a lack of self-protection features, allows every anti-virus program to easily spot this malware."
    }
]